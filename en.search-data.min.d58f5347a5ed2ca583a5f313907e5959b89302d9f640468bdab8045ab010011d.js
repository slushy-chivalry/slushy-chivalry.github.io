'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/posts/','title':"Blog",'content':""});index.add({'id':1,'href':'/posts/universal-algebra-nullary-operations/','title':"Universal algebra nullary operations",'content':"Recall universal algebra approach to definining algebraic structures. Instead of explicitly stating existence of certain elements \u0026ndash; for exapmle, by designating a unit element in a group or associating an inverse \u0026ndash; we replace them with a collection of functions.\nWith this in mind, if  \\(A\\) is a set, a unit element can be replaced with 0-arity function that chooses an element of \\(A\\) . An inverse is a 1-arity function \\(A \\rightarrow A\\) . A group operation (e.g. product) is a 2-arity function \\(A \\times A \\rightarrow A\\) . And so on.\nNow on the other hand, a 0-arity function seems like a misnomer when thought of as number of arguments. If a function selects an element (e.g. a unit element), it can be associated with a function of a one element set \\(\\{*\\} \\rightarrow A\\) that maps that one element set to an element of \\(A\\) . So, as a function, it actually takes 1 argument, not zero.\nHowever, if we think of A as an object in the \\(\\mathbf{Sets}\\) category of sets, we can associate each n-ary universal algebra function with a projection morphism from a finite product of n copies of \\(A\\) . Treating an empty product (a nullary operation) as a terminal object in a category (which coincides with the definition of a terminal object via a limit of an empty diagram) we obtain our \u0026ldquo;selector\u0026rdquo; function \\(\\{*\\} \\rightarrow A\\) . Pretty neat.\nWhat\u0026rsquo;s even neater is that by replacing the category of sets with a category of, say, topological spaces \\(\\mathbf{Top}\\) , we can combine our universal algebra definition to obtain more sophisticated algebraic structures \u0026ndash; in this case, since the morphisms are continuous, we obtain a definition of a topological group. And we only need to change the underlying category. Sweet.\n"});index.add({'id':2,'href':'/posts/partitions-and-selectors/','title':"Partitions and Selectors",'content':"Look at this interesting stuff\nLet I be a finite set, X be another set\nI -\u0026gt; X is a selector function X -\u0026gt; I is a partition function\nfor example, Let I = {0, 1}, X = N\nf: {0, 1} -\u0026gt; N selects two natural numbers g: N -\u0026gt; {0, 1} partitions N into two subsets\nnow, what happenes if we categorify this notion\nI becomes a discrete category \u0026ndash; elements as objects, only identity morphisms X becomes a category of all sets\nfunctions become functors\nF : I -\u0026gt; Sets G : Sets -\u0026gt; I\nbut now, F does what g used to do -\u0026gt; it selects a sets, essentially selecting a partition for a particular set\nthe set is not guaranteed to be a subset of a given set\n what happens if we turn I into a poset category? what happens if we turn X into a poset category? (treating a set A as a poset, ordered by inclusion, with elements as objects and inclusions as morphisms)  let\u0026rsquo;s go even further \u0026ndash; what we really did here is defined a functor H : Sets -\u0026gt; Cat turning each set into a category (I becomes a discrete category, X becomes a Sets category)\n"});})();