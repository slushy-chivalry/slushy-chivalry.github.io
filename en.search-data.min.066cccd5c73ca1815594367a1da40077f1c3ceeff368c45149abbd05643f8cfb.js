'use strict';(function(){const indexCfg={cache:true};indexCfg.doc={id:'id',field:['title','content'],store:['title','href'],};const index=FlexSearch.create('balance',indexCfg);window.bookSearchIndex=index;index.add({'id':0,'href':'/posts/','title':"Blog",'content':""});index.add({'id':1,'href':'/posts/primitive-recursion/','title':"Primitive recursion",'content':"Finding a primitive recursion representation of a given function  \\(f\\) can be reduced to finding functions \\(g, h, k\\) such that\n \\(f(m,0) = g(m)\\)  \\(f(m,S(n)) = k(h(m,n), f(m,n))\\)   where \\(S: \\mathbf{N} \\rightarrow \\mathbf{N}\\) is a successor function turning a natural number into its successor (1 maps to 2, 2 maps to 3, and so on).\nThe sought functions should be a composition of one of the following primitive functions:\n \\(Zero: \\mathbf{N} \\rightarrow \\mathbf{N}, Zero(n) = 0 \\)  \\(S: \\mathbf{N} \\rightarrow \\mathbf{N}, S(n) = n\u0026#43;1 \\)  \\(\\pi_i: \\mathbf{N} \\rightarrow \\mathbf{N^d}, \\pi_i ((n_1, n_2, \\dots, \\n_d)) = n_i \\)   which are called zero, successor, and projection (on i) respectively.\nHow does this relate to our informal definition of recursion? Let\u0026rsquo;s take a look at an addition function \\(add: \\mathbf{N} \\times \\mathbf{N} \\rightarrow \\mathbf{N} \\) that simply adds two natural numbers. Since \\(m \u0026#43; (n \u0026#43; 1) = (m \u0026#43; n) \u0026#43; 1\\) we can define addition recursively as \\(add(m, S(n)) = S(add(m, n))\\) .\nTo get the definition match up with the definition above, note that \\(add(n, 0) = n = id_{\\mathbf{N}}\\) is the identity function on \\(\\mathbf{N}\\) . That gives us our function \\(g = id_{\\mathbf{N}}\\) Since we\u0026rsquo;re trying to extract the second part of the pair in (2) in the definition of the recursive function, our function \\(k\\) should be something related to the projection operation and successor. The only sensible to combine functions so far is to compose them, so let \\(k = S \\circ \\pi_2\\) . We don\u0026rsquo;t care about \\(h\\) since the projection ignores it, but it still has to be a valid function. We can use \\(h = Z \\circ \\pi_1\\) as a valid function (since we gotta make sure it takes 2 arguments).\nPutting it all together, we get\n \\(add(m,0) = id(m)\\)  \\(add(m,S(n)) = (S \\circ \\pi_2)((Zero \\circ \\pi_1)(m,n), add(m,n))\\)   Which now looks like the primitive recursive definition\n"});index.add({'id':2,'href':'/posts/universal-algebra-nullary-operations/','title':"Universal algebra nullary operations",'content':"Recall universal algebra approach to definining algebraic structures. Instead of explicitly stating existence of certain elements \u0026ndash; for exapmle, by designating a unit element in a group or associating an inverse \u0026ndash; we replace them with a collection of functions.\nWith this in mind, if  \\(A\\) is a group, a unit element can be replaced with 0-arity function that chooses an element of \\(A\\) . An inverse is a 1-arity function \\(A \\rightarrow A\\) . A group operation (e.g. product) is a 2-arity function \\(A \\times A \\rightarrow A\\) . And so on.\nNow on the other hand, a 0-arity function seems like a misnomer when thought of as number of arguments. If a function selects an element (e.g. a unit element), it can be associated with a function of a one element set \\(\\{*\\} \\rightarrow A\\) that maps that one element set to an element of \\(A\\) . So, as a function, it actually takes 1 argument, not zero.\nHowever, if we think of A as an object in the \\(\\mathbf{Sets}\\) category of sets, we can associate each n-ary universal algebra function with a projection morphism from a finite product of n copies of \\(A\\) . Treating an empty product (a nullary operation) as a terminal object in a category (which coincides with the definition of a terminal object via a limit of an empty diagram) we obtain our \u0026ldquo;selector\u0026rdquo; function \\(\\{*\\} \\rightarrow A\\) . Pretty neat.\nWhat\u0026rsquo;s even neater is that by replacing the category of sets with a category of, say, topological spaces \\(\\mathbf{Top}\\) , we can combine our universal algebra definition to obtain more sophisticated algebraic structures \u0026ndash; in this case, since the morphisms are continuous, we obtain a definition of a topological group. And we only need to change the underlying category. Sweet.\n"});index.add({'id':3,'href':'/posts/partitions-and-selectors/','title':"Partitions and Selectors",'content':"Look at this interesting stuff\nLet I be a finite set, X be another set\nI -\u0026gt; X is a selector function X -\u0026gt; I is a partition function\nfor example, Let I = {0, 1}, X = N\nf: {0, 1} -\u0026gt; N selects two natural numbers g: N -\u0026gt; {0, 1} partitions N into two subsets\nnow, what happenes if we categorify this notion\nI becomes a discrete category \u0026ndash; elements as objects, only identity morphisms X becomes a category of all sets\nfunctions become functors\nF : I -\u0026gt; Sets G : Sets -\u0026gt; I\nbut now, F does what g used to do -\u0026gt; it selects a sets, essentially selecting a partition for a particular set\nthe set is not guaranteed to be a subset of a given set\n what happens if we turn I into a poset category? what happens if we turn X into a poset category? (treating a set A as a poset, ordered by inclusion, with elements as objects and inclusions as morphisms)  let\u0026rsquo;s go even further \u0026ndash; what we really did here is defined a functor H : Sets -\u0026gt; Cat turning each set into a category (I becomes a discrete category, X becomes a Sets category)\n"});})();